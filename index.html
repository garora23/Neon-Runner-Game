<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NEON RUNNER</title>
    <link href="https://cdn.tailwindcss.com" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0a0a0f;
            --bg-secondary: #12121a;
            --fg: #e0e0e0;
            --muted: #4a4a5a;
            --accent: #00ffaa;
            --accent-secondary: #ff006e;
            --card: #1a1a24;
            --border: #2a2a3a;
            --glow: rgba(0, 255, 170, 0.5);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg);
            color: var(--fg);
            min-height: 100vh;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .font-display { font-family: 'Orbitron', sans-serif; }

        /* Background Effects */
        .bg-grid {
            position: fixed;
            inset: 0;
            background-image: 
                linear-gradient(rgba(0, 255, 170, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 170, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes gridMove {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50px); }
        }

        .glow-orb {
            position: fixed;
            width: 400px;
            height: 400px;
            border-radius: 50%;
            filter: blur(100px);
            opacity: 0.3;
            pointer-events: none;
            z-index: 0;
        }

        .orb-1 {
            background: var(--accent);
            top: -100px;
            right: -100px;
            animation: float1 8s ease-in-out infinite;
        }

        .orb-2 {
            background: var(--accent-secondary);
            bottom: -100px;
            left: -100px;
            animation: float2 10s ease-in-out infinite;
        }

        @keyframes float1 {
            0%, 100% { transform: translate(0, 0); }
            50% { transform: translate(-50px, 50px); }
        }

        @keyframes float2 {
            0%, 100% { transform: translate(0, 0); }
            50% { transform: translate(50px, -50px); }
        }

        /* Game Container */
        .game-wrapper { position: relative; z-index: 1; width: 100%; max-width: 800px; padding: 1rem; }

        #gameCanvas, #particleCanvas {
            display: block;
            border-radius: 12px;
            position: absolute;
            top: 0;
            left: 0;
        }

        #gameCanvas {
            border: 2px solid var(--border);
            background: linear-gradient(180deg, #0d0d14 0%, #151520 100%);
            box-shadow: 0 0 30px rgba(0, 255, 170, 0.1), inset 0 0 60px rgba(0, 0, 0, 0.5);
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 300px;
        }

        /* Buttons */
        .btn-neon {
            position: relative;
            padding: 14px 28px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
            border: 2px solid var(--accent);
            background: transparent;
            color: var(--accent);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .btn-neon::before {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--accent);
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 0;
        }

        .btn-neon:hover {
            color: var(--bg);
            box-shadow: 0 0 20px var(--glow), 0 0 40px var(--glow);
        }

        .btn-neon:hover::before { opacity: 1; }
        .btn-neon span { position: relative; z-index: 1; }
        .btn-neon:active { transform: scale(0.95); }

        /* Overlays (Start & Game Over) */
        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(10, 10, 15, 0.92);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
            z-index: 10;
        }

        .overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* Score Display */
        .score-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 48px;
            font-weight: 900;
            color: var(--accent);
            text-shadow: 0 0 20px var(--glow);
            letter-spacing: 4px;
        }
        .high-score { color: var(--accent-secondary); text-shadow: 0 0 20px rgba(255, 0, 110, 0.5); }

        /* Touch Controls */
        .touch-area { display: none; }
        @media (max-width: 768px) { .touch-area { display: flex; } }

        .touch-btn {
            width: 80px; height: 80px;
            border-radius: 50%;
            border: 2px solid var(--accent);
            background: rgba(0, 255, 170, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            transition: all 0.2s ease;
        }
        .touch-btn:active { background: rgba(0, 255, 170, 0.3); transform: scale(0.9); }

        /* Animations */
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .animate-pulse-slow { animation: pulse 2s ease-in-out infinite; }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .slide-in { animation: slideIn 0.5s ease-out forwards; }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <!-- Background effects -->
    <div class="bg-grid"></div>
    <div class="glow-orb orb-1"></div>
    <div class="glow-orb orb-2"></div>

    <div class="game-wrapper">
        <!-- Header -->
        <header class="flex flex-col sm:flex-row items-center justify-between gap-4 mb-6 slide-in">
            <div>
                <h1 class="font-display text-3xl sm:text-4xl font-black tracking-wider" style="color: var(--accent);">NEON RUNNER</h1>
                <p class="text-sm mt-1" style="color: var(--muted);">Endless cyberpunk chase</p>
            </div>
            <div class="flex items-center gap-6">
                <div class="text-center">
                    <div class="text-xs uppercase tracking-widest mb-1" style="color: var(--muted);">Score</div>
                    <div id="currentScore" class="score-display text-2xl">00000</div>
                </div>
                <div class="text-center">
                    <div class="text-xs uppercase tracking-widest mb-1" style="color: var(--muted);">Best</div>
                    <div id="highScore" class="score-display high-score text-2xl">00000</div>
                </div>
            </div>
        </header>

        <!-- Game Canvas Container -->
        <div class="canvas-container slide-in" style="animation-delay: 0.1s;">
            <canvas id="gameCanvas"></canvas>
            <canvas id="particleCanvas"></canvas>
            
            <!-- Start Overlay -->
            <div id="startOverlay" class="overlay active">
                <h2 class="font-display text-5xl font-black mb-4 animate-pulse-slow" style="color: var(--accent); text-shadow: 0 0 30px var(--glow);">READY?</h2>
                <p class="text-lg mb-8" style="color: var(--muted);">Press Start or Space to Run</p>
                <button id="startBtn" class="btn-neon text-xl px-10 py-4">
                    <span>Start Game</span>
                </button>
            </div>

            <!-- Game Over Overlay -->
            <div id="gameOverOverlay" class="overlay">
                <h2 class="font-display text-4xl font-black mb-2" style="color: var(--accent-secondary);">GAME OVER</h2>
                <p id="finalScore" class="text-xl mb-6" style="color: var(--muted);">Score: 0</p>
                <button id="restartBtn" class="btn-neon">
                    <span>Try Again</span>
                </button>
            </div>
        </div>

        <!-- Touch controls (Mobile only) -->
        <div class="touch-area items-center justify-center gap-8 mt-6">
            <button id="touchJump" class="touch-btn">
                <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="color: var(--accent);"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
            </button>
            <button id="touchDuck" class="touch-btn">
                <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="color: var(--accent);"><path d="M12 5v14M5 12l7 7 7-7"/></svg>
            </button>
        </div>

        <!-- Instructions -->
        <div class="mt-8 text-center slide-in text-sm" style="animation-delay: 0.4s; color: var(--muted);">
            <span class="inline-block px-2 py-1 border border-gray-700 rounded mr-1">Space</span> Jump
            <span class="mx-2">|</span>
            <span class="inline-block px-2 py-1 border border-gray-700 rounded mr-1">S</span> Duck
        </div>
    </div>

    <script>
        // --- Configuration & State ---
        const CONFIG = {
            gravity: 0.6,
            speedIncrement: 0.003,
            obstacleSpawnRate: 1500,
            initialSpeed: 6,
            jumpForce: -13,
            duckHeight: 35,
            groundHeight: 20
        };

        const gameState = {
            score: 0,
            highScore: parseInt(localStorage.getItem('neonRunnerHighScore')) || 0,
            speed: CONFIG.initialSpeed,
            isPlaying: false,
            isGameOver: false,
            hasStarted: false
        };

        // --- Canvas Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const particleCanvas = document.getElementById('particleCanvas');
        const particleCtx = particleCanvas.getContext('2d');
        
        // Define colors for drawing
        const COLORS = {
            accent: '#00ffaa',
            accentSecondary: '#ff006e',
            ground: '#1a1a24',
            groundLine: '#00ffaa',
            player: '#00ffaa',
            visor: '#ff006e',
            obstacle: '#ff006e',
            sky: '#0d0d14'
        };

        function resizeCanvas() {
            const container = canvas.parentElement;
            const width = container.offsetWidth;
            const height = 300; 
            canvas.width = width;
            canvas.height = height;
            particleCanvas.width = width;
            particleCanvas.height = height;
            player.groundY = canvas.height - CONFIG.groundHeight - player.height;
            if(!gameState.isPlaying && !gameState.isGameOver) {
                player.y = player.groundY; 
            }
        }

        // --- Player Character (Cyber-Runner) ---
        const player = {
            x: 50,
            y: 0,
            width: 40,
            height: 60,
            velocityY: 0,
            isJumping: false,
            isDucking: false,
            groundY: 0,
            runFrame: 0,

            init() {
                this.height = 60;
                this.groundY = canvas.height - CONFIG.groundHeight - this.height;
                this.y = this.groundY;
                this.velocityY = 0;
                this.isJumping = false;
                this.isDucking = false;
            },

            jump() {
                if (!this.isJumping && !this.isDucking) {
                    this.velocityY = CONFIG.jumpForce;
                    this.isJumping = true;
                    createParticles(this.x + this.width / 2, this.y + this.height, 15, COLORS.accent);
                }
            },

            duck(active) {
                if (!this.isJumping) {
                    this.isDucking = active;
                    if (active) {
                        this.height = CONFIG.duckHeight;
                        this.groundY = canvas.height - CONFIG.groundHeight - this.height;
                        this.y = this.groundY;
                    } else {
                        this.height = 60;
                        this.groundY = canvas.height - CONFIG.groundHeight - this.height;
                        this.y = this.groundY;
                    }
                }
            },

            update() {
                this.velocityY += CONFIG.gravity;
                this.y += this.velocityY;

                if (this.y >= this.groundY) {
                    this.y = this.groundY;
                    this.velocityY = 0;
                    this.isJumping = false;
                }
                
                if (!this.isJumping && gameState.isPlaying) {
                    this.runFrame += 0.3;
                }
            },

            draw() {
                ctx.save();
                ctx.shadowColor = COLORS.accent;
                ctx.shadowBlur = 15;
                ctx.fillStyle = COLORS.player;

                if (this.isDucking) {
                    // Sliding pose
                    ctx.fillRect(this.x - 5, this.y + 5, this.width + 20, this.height - 10);
                    ctx.fillRect(this.x + this.width, this.y + 5, 20, 25);
                    ctx.fillStyle = COLORS.visor;
                    ctx.fillRect(this.x + this.width + 5, this.y + 12, 12, 6);
                    
                } else {
                    const bobY = this.isJumping ? 0 : Math.sin(this.runFrame) * 3;

                    // Legs
                    ctx.fillStyle = COLORS.player;
                    const legOffset = Math.sin(this.runFrame) * 15;
                    ctx.fillRect(this.x + 10, this.y + this.height - 5, 8, 15 + (this.isJumping ? 5 : legOffset));
                    ctx.fillRect(this.x + 22, this.y + this.height - 5, 8, 15 + (this.isJumping ? 5 : -legOffset));

                    // Body
                    ctx.fillRect(this.x + 8, this.y + 20 + bobY, 24, 30);

                    // Arms
                    ctx.fillRect(this.x, this.y + 25 + bobY + (this.isJumping ? -10 : Math.sin(this.runFrame)*5), 8, 20);
                    ctx.fillRect(this.x + 32, this.y + 25 + bobY + (this.isJumping ? -10 : -Math.sin(this.runFrame)*5), 8, 20);

                    // Head
                    ctx.fillRect(this.x + 5, this.y + bobY, 30, 25);

                    // Visor
                    ctx.fillStyle = COLORS.visor;
                    ctx.shadowColor = COLORS.visor;
                    ctx.fillRect(this.x + 8, this.y + 8 + bobY, 24, 8);
                    
                    // Antenna
                    ctx.fillStyle = COLORS.player;
                    ctx.shadowColor = COLORS.accent;
                    ctx.fillRect(this.x + this.width/2 - 1, this.y - 10 + bobY, 4, 15);
                    ctx.beginPath(); 
                    ctx.arc(this.x + this.width/2, this.y - 12 + bobY, 4, 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.restore();
            },

            getHitbox() {
                return {
                    x: this.x + 5,
                    y: this.y + 5,
                    width: this.width - 10,
                    height: this.height - 10
                };
            }
        };

        // --- Obstacles ---
        const obstacles = [];

        class Obstacle {
            constructor() {
                this.type = Math.random() > 0.3 ? 'spike' : 'drone';
                this.width = this.type === 'spike' ? 30 : 50;
                this.height = this.type === 'spike' ? 50 : 30;
                this.x = canvas.width + 50;
                
                if (this.type === 'drone') {
                    this.y = canvas.height - CONFIG.groundHeight - 50 - Math.random() * 80;
                    this.wingPhase = 0;
                } else {
                    this.y = canvas.height - CONFIG.groundHeight - this.height;
                }
            }

            update() {
                this.x -= gameState.speed;
                if (this.type === 'drone') {
                    this.wingPhase += 0.3;
                }
            }

            draw() {
                ctx.save();
                ctx.shadowColor = COLORS.obstacle;
                ctx.shadowBlur = 15;
                ctx.fillStyle = COLORS.obstacle;

                if (this.type === 'spike') {
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + this.height);
                    ctx.lineTo(this.x + this.width / 2, this.y);
                    ctx.lineTo(this.x + this.width, this.y + this.height);
                    ctx.fill();
                    
                    ctx.strokeStyle = 'rgba(255, 0, 110, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x + 5, this.y + this.height - 5);
                    ctx.lineTo(this.x + this.width/2, this.y + 10);
                    ctx.stroke();
                    
                } else {
                    const wingY = Math.sin(this.wingPhase) * 5;
                    ctx.fillRect(this.x, this.y + 10, this.width, 15);
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(this.x + 15, this.y + 15, 10, 5);
                    ctx.fillStyle = COLORS.obstacle;
                    ctx.fillRect(this.x - 10, this.y + 5 + wingY, 20, 8);
                    ctx.fillRect(this.x + this.width - 10, this.y + 5 - wingY, 20, 8);
                }
                ctx.restore();
            }

            getHitbox() {
                return {
                    x: this.x + 5,
                    y: this.y + 5,
                    width: this.width - 10,
                    height: this.height - 10
                };
            }
        }

        // --- Particles ---
        const particles = [];

        function createParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    size: Math.random() * 4 + 2,
                    color: color,
                    life: 1
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.03;
                p.size *= 0.97;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function drawParticles() {
            particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
            particles.forEach(p => {
                particleCtx.save();
                particleCtx.globalAlpha = p.life;
                particleCtx.fillStyle = p.color;
                particleCtx.shadowColor = p.color;
                particleCtx.shadowBlur = 5;
                particleCtx.beginPath();
                particleCtx.arc(p.x, p.y, Math.max(0.1, p.size), 0, Math.PI * 2);
                particleCtx.fill();
                particleCtx.restore();
            });
        }

        // --- Background & World ---
        let groundOffset = 0;
        const stars = [];
        for (let i = 0; i < 30; i++) {
            stars.push({ x: Math.random() * 1000, y: Math.random() * 200, size: Math.random() * 2, twinkle: Math.random() * Math.PI * 2 });
        }

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0d0d14');
            gradient.addColorStop(1, '#151520');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            stars.forEach(star => {
                star.twinkle += 0.05;
                const alpha = 0.5 + Math.sin(star.twinkle) * 0.3;
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc((star.x - groundOffset * 0.05) % canvas.width, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawGround() {
            ctx.strokeStyle = COLORS.groundLine;
            ctx.lineWidth = 2;
            ctx.shadowColor = COLORS.groundLine;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - CONFIG.groundHeight);
            ctx.lineTo(canvas.width, canvas.height - CONFIG.groundHeight);
            ctx.stroke();
            ctx.shadowBlur = 0;

            ctx.strokeStyle = 'rgba(0, 255, 170, 0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width + 50; i += 40) {
                const x = (i - groundOffset % 40);
                ctx.beginPath();
                ctx.moveTo(x, canvas.height - CONFIG.groundHeight + 5);
                ctx.lineTo(x + 20, canvas.height - CONFIG.groundHeight + 5);
                ctx.stroke();
            }
        }

        // --- Game Logic ---
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        let lastObstacleTime = 0;

        function spawnObstacle() {
            const now = Date.now();
            const dynamicRate = CONFIG.obstacleSpawnRate - (gameState.speed * 20);
            if (now - lastObstacleTime > Math.max(800, dynamicRate)) {
                obstacles.push(new Obstacle());
                lastObstacleTime = now;
            }
        }

        function startGame() {
            if (gameState.hasStarted && !gameState.isGameOver) return;
            
            document.getElementById('startOverlay').classList.remove('active');
            document.getElementById('gameOverOverlay').classList.remove('active');
            
            gameState.score = 0;
            gameState.speed = CONFIG.initialSpeed;
            gameState.isPlaying = true;
            gameState.isGameOver = false;
            gameState.hasStarted = true;
            
            obstacles.length = 0;
            particles.length = 0;
            lastObstacleTime = Date.now();
            
            player.init();
            updateScoreDisplay();
        }

        function gameOver() {
            gameState.isGameOver = true;
            gameState.isPlaying = false;
            gameState.hasStarted = false;
            createParticles(player.x + player.width / 2, player.y + player.height / 2, 40, COLORS.accentSecondary);
            
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('neonRunnerHighScore', gameState.highScore);
            }

            document.getElementById('finalScore').textContent = `Score: ${String(gameState.score).padStart(5, '0')}`;
            document.getElementById('gameOverOverlay').classList.add('active');
            updateScoreDisplay();
        }

        function updateScoreDisplay() {
            document.getElementById('currentScore').textContent = String(Math.floor(gameState.score)).padStart(5, '0');
            document.getElementById('highScore').textContent = String(gameState.highScore).padStart(5, '0');
        }

        // --- Main Game Loop ---
        function gameLoop() {
            if (gameState.isPlaying) {
                groundOffset += gameState.speed;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            drawGround();

            if (gameState.isPlaying) {
                player.update();
                spawnObstacle();

                for (let i = obstacles.length - 1; i >= 0; i--) {
                    obstacles[i].update();
                    if (checkCollision(player.getHitbox(), obstacles[i].getHitbox())) {
                        gameOver();
                        break;
                    }
                    if (obstacles[i].x + obstacles[i].width < 0) {
                        obstacles.splice(i, 1);
                    }
                }

                gameState.score += 0.1;
                gameState.speed = CONFIG.initialSpeed + (gameState.score * CONFIG.speedIncrement);
                updateScoreDisplay();
            } 

            obstacles.forEach(o => o.draw());
            player.draw();

            updateParticles();
            drawParticles();

            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        document.addEventListener('keydown', (e) => {
            if (['Space', 'ArrowUp', 'KeyW'].includes(e.code)) {
                e.preventDefault();
                if (!gameState.hasStarted || gameState.isGameOver) startGame();
                else if (gameState.isPlaying) player.jump();
            }
            if (['ArrowDown', 'KeyS'].includes(e.code)) {
                e.preventDefault();
                if (gameState.isPlaying) player.duck(true);
            }
        });

        document.addEventListener('keyup', (e) => {
            if (['ArrowDown', 'KeyS'].includes(e.code)) player.duck(false);
        });

        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);

        // Touch
        document.getElementById('touchJump').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.hasStarted || gameState.isGameOver) startGame();
            else if (gameState.isPlaying) player.jump();
        });
        document.getElementById('touchDuck').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState.isPlaying) player.duck(true);
        });
        document.getElementById('touchDuck').addEventListener('touchend', (e) => {
            e.preventDefault(); player.duck(false);
        });

        // Initialize
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        player.init();
        updateScoreDisplay();
        gameLoop();
    </script>
</body>
</html>